import 'dart:convert';

import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:collection/collection.dart';
import 'package:open_api_specification/open_api.dart';
import 'package:open_api_specification/open_api_spec.dart';
import 'package:shelf_open_api/shelf_open_api.dart';
import 'package:shelf_open_api_generator/src/config.dart';
import 'package:shelf_open_api_generator/src/handlers/route_handler.dart';
import 'package:shelf_open_api_generator/src/schemas_registry.dart';
import 'package:shelf_open_api_generator/src/utils/doc.dart';
import 'package:shelf_open_api_generator/src/utils/utils.dart';
import 'package:shelf_open_api_generator/src/utils/yaml_encoder.dart';
import 'package:source_gen/source_gen.dart';
import 'package:yaml/yaml.dart';

class OpenApiHandler {
  static final _openApiFileChecker = TypeChecker.fromRuntime(OpenApiFile);
  static final _jsonEncoder = JsonEncoder();
  static final _yamlEncoder = YamlEncoder(
    shouldMultilineStringInBlock: false,
    toEncodable: (o) => o.toJson(),
  );

  final Config config;
  final Pubspec? pubspec;
  final OpenApiFileFormat fileFormat;
  final ClassElement element;
  final SchemasRegistry schemasRegistry = SchemasRegistry();

  OpenApiHandler._({
    required this.config,
    required this.pubspec,
    required this.element,
    required this.fileFormat,
  });

  static Future<OpenApiHandler?> from(Config config, BuildStep buildStep) async {
    final library = await buildStep.resolver.libraryFor(buildStep.inputId);
    final libraryReader = LibraryReader(library);

    final annotatedElements = libraryReader.classes.mapWhereNotNull((element) {
      final annotation = _openApiFileChecker.firstAnnotationOf(element);
      if (annotation == null) return null;
      return (element, annotation);
    }).toList();
    if (annotatedElements.isEmpty) return null;

    final annotatedElement = annotatedElements.singleOrNull;
    if (annotatedElement == null) {
      throw InvalidGenerationSourceError(
        'The shelf_open_api.OpenApiFile annotation can only be used to a ONE class per file',
      );
    }
    final (element, annotation) = annotatedElement;

    final fileFormat = switch (annotation.getField('format')!.variable!.name) {
      'json' => OpenApiFileFormat.json,
      'yaml' => OpenApiFileFormat.yaml,
      final format => throw InvalidGenerationSourceError(
        'The format "$format" in shelf_open_api.OpenApiFile annotation is not supported',
        element: element,
      ),
    };

    final version = await Pubspec.read(buildStep);

    return OpenApiHandler._(
      config: config,
      pubspec: version,
      element: element,
      fileFormat: fileFormat,
    );
  }

  OpenApi buildOpenApi(List<OpenRouteHandler> routes) {
    final routesInPaths = routes.groupListsBy((e) => e.path);

    return OpenApi(
      openapi: '3.0.0',
      info: _buildInfoSpecs(),
      servers: [_buildServerSpecs()],
      paths: routesInPaths.map((path, routes) {
        final item = ItemPathOpenApi.from(
          operations: routes.toMap((route) {
            final operation = route.buildOperation();
            return MapEntry(route.verb, operation);
          }),
        );
        return MapEntry(path, item);
      }),
      components: ComponentsOpenApi(securitySchemes: config.securitySchemes),
      tags: _buildTags(routes),
    );
  }

  InfoOpenApi _buildInfoSpecs() {
    return InfoOpenApi(
      title: config.infoTitle ?? pubspec?.name ?? 'Api',
      description:
          config.infoDescription ??
          pubspec?.description ??
          'Open api specifications generated by shelf_open_api dart package',
      termsOfService: config.infoTermsOfService,
      version: config.infoVersion ?? pubspec?.version ?? '0.0.0',
    );
  }

  ServerOpenApi _buildServerSpecs() {
    return ServerOpenApi(description: config.serverDescription, url: config.serverUrl);
  }

  List<TagOpenApi> _buildTags(List<OpenRouteHandler> routes) {
    return routes.map((e) => e.element.enclosingElement3 as ClassElement).toSet().map((e) {
      return TagOpenApi(name: e.displayName, description: Doc.clean(e.documentationComment));
    }).toList();
  }

  (String, String) code(List<OpenRouteHandler> routes) {
    final openApi = buildOpenApi(routes);
    final rawOpenApi = organizeOpenApi(openApi.toJson());

    final code = switch (fileFormat) {
      OpenApiFileFormat.json => _jsonEncoder.convert(rawOpenApi),
      OpenApiFileFormat.yaml => _yamlEncoder.convert(rawOpenApi),
    };
    return ('.${fileFormat.name}', code);
  }
}

class Pubspec {
  final String name;
  final String? description;
  final String? version;

  const Pubspec({required this.name, required this.description, required this.version});

  static Future<Pubspec?> read(BuildStep buildStep) async {
    final pubspecAssetId = AssetId(buildStep.inputId.package, 'pubspec.yaml');
    if (!await buildStep.canRead(pubspecAssetId)) return null;

    final rawContent = await buildStep.readAsString(pubspecAssetId);
    final content = loadYaml(rawContent, sourceUrl: pubspecAssetId.uri) as YamlMap;

    return Pubspec(
      name: content['name'] as String,
      description: content['description'] as String?,
      version: content['version'] as String?,
    );
  }
}
