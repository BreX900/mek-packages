library shelf_routing;

import 'package:meta/meta_meta.dart';

export 'package:shelf_routing/src/get_request_extension.dart';
export 'package:shelf_routing/src/json_response.dart';
export 'package:shelf_routing/src/utils.dart';

/// Annotation for top level getters to generate a router that handles all routers of the types
/// passed using the package `shelf_routing_generator`.
///
/// **Example**
/// ```dart
/// // Always import 'shelf_router' without 'show' or 'as'.
/// import 'package:shelf_router/shelf_router.dart';
/// // Always import 'shelf_routing' without 'show' or 'as'.
/// import 'package:shelf_routing/shelf_routing.dart' show Request, Response;
///
/// // Include generated code, this assumes current file is 'services_router.dart'.
/// part 'services_router.g.dart';
///
/// // Get a router for all these services.
/// @GenerateRouterFor([MyService, MyAnotherService])
/// Router get router => _$router;
/// ```
@Target({TargetKind.getter})
class GenerateRouterFor {
  /// List of services that have a static getter that returns a Router
  final List<Type> routables;

  /// See class documentation
  const GenerateRouterFor(this.routables);
}

/// Annotation for services using on methods the Route annotation to add a [prefix] when the router
/// is mounted via the [GenerateRouterFor] annotation using the package `shelf_routing_generator`.
///
/// **Example**
/// ```dart
/// // Always import 'shelf_router' without 'show' or 'as'.
/// import 'package:shelf_router/shelf_router.dart';
/// // Always import 'shelf_routing' without 'show' or 'as'.
/// import 'package:shelf_routing/shelf_routing.dart' show Request, Response;
///
/// // Include generated code, this assumes current file is 'service.dart'.
/// part 'service.g.dart';
///
/// // Get a router for all these services.
/// @Routable(prefix: '/say-hello')
/// class Service {
///   @Route.get('/<name>')
///   Future<Response> _sayHello(Request request, String name) async {
///     return Response.ok('hello $name');
///   }
///
///   /// Get a router for this service.
///   Router get router => _$ServiceRouter(this);
/// }
/// ```
@Target({TargetKind.classType})
class Routable {
  /// Router prefix
  final String prefix;

  /// See class documentation
  const Routable({required this.prefix});
}

/// Annotation for methods using Route annotation to indicate that the route should be called with
/// this the header [name] using the package `shelf_routing_generator`.
///
/// **Example**
/// ```dart
/// import 'package:shelf/shelf.dart';
/// // Always import 'shelf_routing' without 'show' or 'as'.
/// import 'package:shelf_routing/shelf_routing.dart' show Request, Response;
///
/// // Include generated code, this assumes current file is 'service.dart'.
/// part 'service.g.dart';
///
/// class Service {
///   @Route.get('/<name>')
///   @RouteHeader(name: 'authentication')
///   Future<Response> _sayHello(Request request, String name) async {
///     return Response.ok('hello $name');
///   }
/// }
/// ```
@Target({TargetKind.method})
class RouteHeader {
  /// The header name
  final String name;

  /// See class documentation
  const RouteHeader({required this.name});
}

/// Identifies the data type of the request.
enum BadRequestPosition {
  /// Request header
  header,

  /// Path parameter
  path,

  /// Query parameter
  queryParameter,

  /// Request body
  body,
}

/// The exception that will be thrown in case the validation/parsing of the request fails.
class BadRequestException implements Exception {
  /// Identifies the type of invalid data.
  final BadRequestPosition position;

  /// The error generated by validation/parsing.
  final Object error;

  /// The stack trace generated by validation/parsing.
  final StackTrace stackTrace;

  /// The invalid field name.
  final String? name;

  /// Constructor for a request header error.
  BadRequestException.header(this.error, this.stackTrace, String this.name)
    : position = BadRequestPosition.header;

  /// Constructor for a request path parameter error.
  BadRequestException.path(this.error, this.stackTrace)
    : position = BadRequestPosition.path,
      name = null;

  /// Constructor for a request query parameter error.
  BadRequestException.queryParameter(this.error, this.stackTrace, String this.name)
    : position = BadRequestPosition.queryParameter;

  /// Constructor for a request body error.
  BadRequestException.body(this.error, this.stackTrace)
    : position = BadRequestPosition.body,
      name = null;

  @override
  String toString() =>
      'Missing or invalid ${position.name}${name != null ? ' "$name"' : ''}.\n'
      '$error\n'
      '$stackTrace';
}
